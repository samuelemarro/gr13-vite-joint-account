// SPDX-License-Identifier: MIT
/// @title Joint Account implementation for GR13 Hackathon
/// @author Samuele Marro

pragma soliditypp ^0.8.0;

contract JointAccount {
    uint256 private constant NULL = 2**256 - 1;
    address private constant NULL_ADDRESS = "vite_0000000000000000000000000000000000000000a4f3a0cb58";
    vitetoken private constant NULL_TOKEN = "tti_000000000000000000004cfd";
    enum MotionType { TRANSFER, ADD_MEMBER, REMOVE_MEMBER, CHANGE_THRESHOLD }
    struct Motion {
        MotionType motionType;
        vitetoken tokenId;
        uint256 transferAmount;
        address to;
        uint256 threshold;

        address proposer;
        uint256 voteCount;
        bool active;
    }
    address[] members;
    uint256 approvalThreshold;

    Motion[] motions;
    mapping(uint256 => mapping(address => bool)) votes;

    constructor(address[] memory _members, uint256 _approvalThreshold) {
        require(_members.length > 0, "JointAccount: at least one member must be specified");
        require(_approvalThreshold > 0, "JointAccount: approval threshold must be greater than 0");
        require(_approvalThreshold <= _members.length, "JointAccount: approval threshold must be less than or equal to the number of members");

        members = _members;
        approvalThreshold = _approvalThreshold;
    }

    function createTransferMotion(vitetoken _tokenId, uint256 _transferAmount, address _to) external {
        require(_findMember(msg.sender) != NULL, "JointAccount: not a member");
        motions.push(Motion(MotionType.TRANSFER, _tokenId, _transferAmount, _to, NULL, msg.sender, 0, true));
        _voteMotion(motions.length - 1);
    }

    function createAddMotion(address _member) external {
        require(_findMember(msg.sender) != NULL, "JointAccount: not a member");
        motions.push(Motion(MotionType.ADD_MEMBER, NULL_TOKEN, NULL, _member, NULL, msg.sender, 0, true));
        _voteMotion(motions.length - 1);
    }

    function createRemoveMotion(address _member) external {
        require(_findMember(msg.sender) != NULL, "JointAccount: not a member");
        motions.push(Motion(MotionType.REMOVE_MEMBER, NULL_TOKEN, NULL, _member, NULL, msg.sender, 0, true));
        _voteMotion(motions.length - 1);
    }

    function createChangeThresholdMotion(uint256 _threshold) external {
        require(_findMember(msg.sender) != NULL, "JointAccount: not a member");
        motions.push(Motion(MotionType.CHANGE_THRESHOLD, NULL_TOKEN, NULL, NULL_ADDRESS, _threshold, msg.sender, 0, true));
        _voteMotion(motions.length - 1);
    }

    function _transfer(vitetoken _tokenId, uint256 _transferAmount, address _to) internal {
        require(balance(_tokenId) >= _transferAmount, "JointAccount: insufficient balance");
        payable(_to).transfer(_tokenId, _transferAmount);
    }

    function _addMember(address _member) internal {
        require(_findMember(_member) == NULL, "JointAccount: member already exists");
        members.push(_member);
    }

    function _findMember(address _member) private view returns(uint256) {
        bool found = false;
        uint256 index;
        for (index = 0; index < members.length && !found; index++) {
            if (members[index] == _member) {
                found = true;
            }
        }

        if (found) {
            return index;
        } else {
            return NULL;
        }
    }

    function _removeMember(address _member) internal {
        uint256 index = _findMember(_member);
        require(index != NULL, "JointAccount: member not found");

        for (uint256 i = index; i < members.length - 1; i++) {
            members[i] = members[i + 1];
        }

        members.pop();
    }

    function _changeThreshold(uint256 _threshold) internal {
        approvalThreshold = _threshold;
    }

    function _voteMotion(uint256 _motionId) internal {
        votes[_motionId][msg.sender] = true;
        motions[_motionId].voteCount++;

        if (motions[_motionId].voteCount >= approvalThreshold) {
            motions[_motionId].active = false;

            // Note: Solidity doesn't have switch statements
            if (motions[_motionId].motionType == MotionType.TRANSFER) {
                _transfer(motions[_motionId].tokenId, motions[_motionId].transferAmount, motions[_motionId].to);
            } else if (motions[_motionId].motionType == MotionType.ADD_MEMBER) {
                _addMember(motions[_motionId].to);
            } else if (motions[_motionId].motionType == MotionType.REMOVE_MEMBER) {
                _removeMember(motions[_motionId].to);
            } else if (motions[_motionId].motionType == MotionType.CHANGE_THRESHOLD) {
                _changeThreshold(motions[_motionId].threshold);
            }
        }
    }

    function voteMotion(uint256 _motionId) internal {
        require(_findMember(msg.sender) != NULL, "JointAccount: not a member");
        require(motions[_motionId].active, "JointAccount: motion is not active");
        require(!votes[_motionId][msg.sender], "JointAccount: you have already voted on this motion");
        _voteMotion(_motionId);
    }

    function cancelVote(uint256 _motionId) internal {
        require(_findMember(msg.sender) != NULL, "JointAccount: not a member");
        require(motions[_motionId].active, "JointAccount: motion is not active");
        require(votes[_motionId][msg.sender], "JointAccount: you have not voted on this motion");
        votes[_motionId][msg.sender] = false;
        motions[_motionId].voteCount--;
    }

    function cancelMotion(uint256 _motionId) internal {
        require(_findMember(msg.sender) != NULL, "JointAccount: not a member");
        require(motions[_motionId].active, "JointAccount: motion is not active");
        require(motions[_motionId].proposer == msg.sender, "JointAccount: you are not the proposer of this motion");
        motions[_motionId].active = false;
    }

}